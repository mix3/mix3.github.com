package Blog;

use strict;
use warnings;
use utf8;

use Cwd  qw/realpath/;
use Carp qw/croak/;
use FindBin;
use File::Path qw/mkpath/;
use Text::Xslate;
use Encode;
use File::Basename;
use DateTime::Format::Strptime;
use Data::Page::Navigation;
use HTML::TagCloud;

sub new {
	my $proto = shift;
	my $class = ref $proto || $proto;
	my $self  = ref $_[0] eq 'HASH' ? $_[0] : {@_};
	return bless $self, $class;
}

sub root_dir {
	my $self = shift;
	unless ($self->{root_dir}) {
		$self->{root_dir} ||= realpath($FindBin::Bin.'/..');
	}
	return $self->{root_dir};
}

sub config_file {
	my $self = shift;
	unless ($self->{config_file}) {
		$self->{config_file} ||= 'config.pl';
	}
	return $self->{config_file};
}

sub config {
	my $self = shift;
	unless ($self->{config}) {
		unless (-f $self->root_dir . '/' . $self->config_file) {
			croak(
				$self->config_file . ' not found: '
				. $self->root_dir . '/' . $self->config_file
			);
		}
		$self->{config} = do $self->root_dir . '/' . $self->config_file;
		$self->{config}->{resource} ||= '.resource';
		$self->{config}->{template} ||= '.template';
	}
	return $self->{config};
}

sub resource_dir {
	my $self = shift;
	unless ($self->{resource_dir}) {
		unless (-d $self->root_dir . '/' . $self->config->{resource}) {
			croak(
				$self->config->{resource}.'/ not found: '
				. $self->root_dir . '/' . $self->config->{resource}
			);
		}
		$self->{resource_dir} = $self->root_dir . '/' . $self->config->{resource};
	}
	return $self->{resource_dir};
}

sub template_dir {
	my $self = shift;
	unless ($self->{template_dir}) {
		unless (-d $self->root_dir . '/' . $self->config->{template}) {
			croak(
				$self->config->{template}.'/ not found: '
				. $self->root_dir . '/' . $self->config->{template}
			);
		}
		$self->{template_dir} = $self->root_dir . '/' . $self->config->{template};
	}
	return $self->{template_dir};
}

sub tx {
	my $self = shift;
	unless ($self->{tx}) {
		$self->{tx} = Text::Xslate->new(path => [$self->template_dir]);
	}
	return $self->{tx};
}

sub paginate {
	my $self     = shift;
	my $articles = shift;
	my $result = [];
	my @_articles = @$articles;
	while (my @list = splice(@_articles, 0, $self->config->{page_num})) {
		push @$result, \@list;
	}
	return $result;
}

sub _articles {
	my $self = shift;
	my $args = shift;

	unless ($self->{_articles}) {
		$self->{_articles} = [];
		for my $path (glob $self->resource_dir . '/*.md') {
			push @{$self->{_articles}}, Article->new({ path => $path });
		}
	}

	if(!$args->{asc} || $args->{desc}) {
		$self->{_articles}
			= [sort { $b->{date} <=> $a->{date} } @{$self->{_articles}}];
	} elsif ($args->{asc}) {
		$self->{_articles}
			= [sort { $a->{date} <=> $b->{date} } @{$self->{_articles}}];
	}

	return $self->{_articles};
}

sub articles_pager {
	my $self = shift;
	unless ($self->{articles}) {
		$self->{articles} = $self->paginate($self->_articles);
	}
	return $self->{articles};
}

sub _month {
	my $self = shift;
	unless ($self->{_month}) {
		for my $article (@{$self->_articles}) {
			push @{$self->{_month}->{$article->{date}->strftime('%Y%m')}}, $article;
		}
	}
	return $self->{_month};
}

sub month {
	my $self = shift;
	unless ($self->{month}) {
		my $hash = {};
		for my $article (@{$self->_articles}) {
			$hash->{$article->{date}->strftime('%Y%m')} = 1;
		}
		$self->{month} = [sort { $b <=> $a } keys $hash];
	}
	return $self->{month};
}

sub month_to_articles_pager {
	my $self  = shift;
	my $month = shift;
	unless ($self->{month_to_articles}->{$month}) {
		$self->{month_to_articles}->{$month}
			= $self->paginate($self->_month->{$month});
	}
	return $self->{month_to_articles}->{$month};
}

sub month_to_dt {
	my $self  = shift;
	my $month = shift;
	unless ($self->{month_to_dt}->{$month}) {
		my $strp  = DateTime::Format::Strptime->new(
			pattern   => '%Y%m',
			time_zone => 'Asia/Tokyo',
		);
		$self->{month_to_dt}->{$month} = $strp->parse_datetime($month);
	}
	return $self->{month_to_dt}->{$month};
}

sub _category {
	my $self = shift;
	unless ($self->{_category}) {
		for my $article (@{$self->_articles}) {
			for my $category (@{$article->{category}}) {
				push @{$self->{_category}->{$category}}, $article;
			}
		}
	}
	return $self->{_category};
}

sub category {
	my $self = shift;
	unless ($self->{category}) {
		$self->{category} = [sort keys %{$self->_category}];
	}
	return $self->{category};
}

sub category_to_articles_pager {
	my $self     = shift;
	my $category = shift;
	unless ($self->{category_to_article}->{$category}) {
		$self->{category_to_article}->{$category}
			= $self->paginate($self->_category->{$category});
	}
	return $self->{category_to_article}->{$category};
}

sub _tag {
	my $self = shift;
	unless ($self->{_tag}) {
		for my $article (@{$self->_articles}) {
			for my $tag (@{$article->{tag}}) {
				push @{$self->{_tag}->{$tag}}, $article;
			}
		}
	}
	return $self->{_tag};
}

sub tag {
	my $self = shift;
	unless ($self->{tag}) {
		$self->{tag} = [sort keys %{$self->_tag}];
	}
	return $self->{tag};
}

sub tag_to_articles_pager {
	my $self = shift;
	my $tag  = shift;
	unless ($self->{tag_to_article}->{$tag}) {
		$self->{tag_to_article}->{$tag}
			= $self->paginate($self->_tag->{$tag});
	}
	return $self->{tag_to_article}->{$tag};
}

#sub page_to_articles {
#	my $self     = shift;
#	my $articles = shift;
#	my $page     = shift;
#	return [] if ($page - 1 < 0);
#	return $articles->[$page - 1] || [];
#}

sub pager {
	my $self = shift;
	my $list = shift;
	my $page = shift;
	return Data::Page->new(@$list, $self->config->{page_num}, $page);
}

sub sidebar_info {
	my $self = shift;
	return {
		month     => $self->month,
		category  => $self->category,
		tag_cloud => $self->tag_cloud,
	};
}

sub tag_cloud {
	my $self = shift;
	unless ($self->{tag_cloud}) {
		my $tc = HTML::TagCloud->new;
		for my $tag (@{$self->tag}) {
			my $num = 0;
			for my $pager (@{$self->tag_to_articles_pager($tag)}) {
				$num += @$pager;
			}
			$tc->add($tag, '', $num);
		}
		$self->{tag_cloud} = $tc;
	}
	return $self->{tag_cloud};
}

sub output_index {
	my $self = shift;
	my $path = $self->root_dir . '/index.html';
	print $path."\n";
	my $render = $self->tx->render('index.tx', {
		sidebar_info => $self->sidebar_info,
		articles     => $self->articles_pager->[0],
	});
	print encode_utf8($render);
}

sub output_articles {
	my $self = shift;
	for my $article (@{$self->_articles}) {
		my $date = $article->{date}->strftime('/%Y/%d/');
		my $path = $self->root_dir . $date . $article->{name} . '/index.html';
		print $path."\n";
		my $render = $self->tx->render('article.tx', {
			sidebar_info => $self->sidebar_info,
			article      => $article,
		});
		print encode_utf8($render);
	}
}

sub output_page_to_articles {
	my $self = shift;
	my $pager = $self->articles_pager;
	for (my $page = 1; $page <= @$pager; $page++) {
		my $path = $self->root_dir . '/' . $page . '/index.html';
		print $path."\n";
		my $render = $self->tx->render('page.tx', {
			sidebar_info => $self->sidebar_info,
			articles     => $pager->[$page - 1],
		});
		print encode_utf8($render);
	}
}

sub output_month_to_articles {
	my $self = shift;
	for (my $i = 0; $i < @{$self->month}; $i++) {
		my $month = $self->month->[$i];
		my $dt    = $self->month_to_dt($month);
		my $pager = $self->month_to_articles_pager($month);
		for (my $page = 1; $page <= @$pager; $page++) {
			my $path = $self->root_dir
				. $dt->strftime('/%Y/%m/') . $page . '/index.html';
			print $path."\n";
			my $render = $self->tx->render('month.tx', {
				sidebar_info => $self->sidebar_info,
				articles     => $pager->[$page - 1],
			});
			print encode_utf8($render);
		}
	}
}

sub output_category_to_articles {
	my $self = shift;
	for (my $i = 0; $i < @{$self->category}; $i++) {
		my $category = $self->category->[$i];
		my $pager    = $self->category_to_articles_pager($category);
		for (my $page = 1; $page <= @$pager; $page++) {
			my $path = $self->root_dir
				. '/' . $category . '/' . $page . '/index.html';
			print $path."\n";
			my $render = $self->tx->render('category.tx', {
				sidebar_info => $self->sidebar_info,
				articles     => $pager->[$page - 1],
			});
			print encode_utf8($render);
		}
	}
}

sub output_tag_to_articles {
	my $self = shift;
	for (my $i = 0; $i < @{$self->tag}; $i++) {
		my $tag = $self->tag->[$i];
		my $pager    = $self->tag_to_articles_pager($tag);
		for (my $page = 1; $page <= @$pager; $page++) {
			my $path = $self->root_dir
				. '/' . $tag . '/' . $page . '/index.html';
			print $path."\n";
			my $render = $self->tx->render('tag.tx', {
				sidebar_info => $self->sidebar_info,
				articles     => $pager->[$page - 1],
			});
			print encode_utf8($render);
		}
	}
}

sub _output {
	my $self = shift;
	my $args = shift;
	unless ($args->{path}) {
		croak('require path');
	}
	unless ($args->{content}) {
		croak('require content');
	}
	mkpath(dirname($args->{path}));
	open my $fh, '>', $args->{path};
	print $fh encode_utf8($args->{content});
	close $fh;
}

1;
